/*
	5.6. Троллейбусы (4)
	Троллейбусы одного маршрута проходят через остановку каждые K минут. 
	Известны времена прихода N жителей на остановку. 
	Если человек приходит на остановку в момент прихода троллейбуса, то он успевает войти в этот троллейбус. 
	Определить в пределах часа время прибытия первого троллейбуса на остановку T такого, 
	чтобы суммарное время ожидания троллейбуса для всех граждан было минимальным. 
	Если этот минимум достигается в разные моменты прибытия, вывести наиболее раннее время.

	Ввод. 
	Первая строка файла INPUT.TXT содержит целые числа K (2 ≤ K < 60) и N (1 ≤ N ≤ 10'000) через пробел. 
	Во второй строке заданы моменты прихода жителей - N целых числа от 0 до 10'000.
	Вывод. 
	Результат в файле OUTPUT.TXT в виде целого числа T (0 ≤ T ≤ 60).

Пример
Ввод
5 3
1 1 2
Вывод
2

	Игнатьев Владислав, ПС-22
	Visual Studio Community 2022

Суть решения:
	Поначалу я думал, что задача на какую-то универсальную формулу, но оказалось, что нет.
	Мы просто используем полный перебор в связи с маленькой размерностью входных данных (до 10'000).
	Правильно ли я оценил сложность алгоритма? - O(K*N)
	В программы мы перебираем все возможные моменты прибытия троллейбуса (от 0 до K-1), 
	для каждого из них вычисляем суммарное время ожидания для всех жителей и выбираем минимальное.
	 Для вычисления времени ожидания для каждого жителя используем формулу 
	 waitTime = (t - timeOfWaiting[i] % K + K) % K 
	 которая учитывает периодичность прихода троллейбусов.
	 Как выведена формула: 

	 t -  предполагаемый момент времени приезда первого троллейбуса.

	 timeOfWaiting[i] % K вычисляет остаток от деления времени прихода i-го жителя 
	 на периодичность прихода троллейбусов K.

	 (t - timeOfWaiting[i] % K + K) % K вычисляет время ожидания, 
	 учитывая периодичность прихода троллейбусов. Если t - timeOfWaiting[i] % K меньше нуля, 
	 то добавляем K, чтобы получить положительное время ожидания.
Пример:
	Периодичность прихода троллейбусов K = 5, а i-й житель должен ждать троллейбус 
	в момент времени 13, то timeOfWaiting[i] % K = 3, 
	и для t = 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 
	время ожидания будет соответственно 5, 4, 3, 2, 1, 0, 4, 3, 2, 1, 0.
	Проще говоря, я использую ряды вычета по модулю со сдвигом, что, мне кажется, единственно правильным для
	решения данной задачи.

	Предлагаю свои тестовые данные в файлах cinN.txt и ожидаемый вывод в  coutN.txt
	Также есть файл logs.txt в который я вывожу весь перебор
*/

#include <vector>
#include <fstream>
#include <algorithm>

int main()
{
	std::ifstream fin("cin2.txt");
	std::ofstream fout("output.txt");
	std::ofstream logs("logs.txt");

	int K, N;
	fin >> K >> N;

	std::vector<int> timeOfWaiting(N);
	for (int i = 0; i < N; ++i)
	{
		fin >> timeOfWaiting[i];
	}

	int summaryTime = 1'000'000, waitTime, minTime = 0;

	for (int t = 0; t < K; ++t)
	{
		int tempSummaryTime = 0;
		for (int i = 0; i < N; ++i)
		{
			waitTime = (t - timeOfWaiting[i] % K + K) % K; 
			tempSummaryTime += waitTime;
		}

		logs << "For t = " << t << " sum of waiting is " << tempSummaryTime << std::endl;

		if (tempSummaryTime < summaryTime) 
		{
			summaryTime = tempSummaryTime;
			minTime = t;
		}
	}

	fout << minTime << std::endl;

	return 0;
}