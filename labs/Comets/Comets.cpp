/*
10.11. Кометы (6)
    Астроном Коперни увлечен кометами. Он определил новую физическую единицу яркости Co и вывел закон 
    нахождения яркости комет в зависимости от времени в виде Y = At + B. 
    В дальнейших исследованиях ему удалось рассчитать коэффициенты A и B для всех известных комет. 
    Коперни в любой момент времени всегда наблюдает в свой телескоп комету с наибольшей яркостью. 
    Как только у другой кометы яркость оказывается большей, он переносит на нее свои наблюдения. 
    Для заказа нового телескопа ему необходимо знать минимальную яркость наблюдаемой им кометы на определенный период времени. 
    Помогите астроному Коперни.
    Ввод из файла INPUT.TXT. В первой строке указаны N и T (1 ≤ N, T ≤ 2000) – число комет и период наблюдения. 
    В следующих N строках содержатся коэффициенты Ai и Bi (-100 ≤ Ai, Bi ≤ 100) для всех N комет. 
    Все числа N, T, Ai, Bi целые. Необходимо иметь в виду, что яркость кометы в единицах 
    Co может быть как положительной, так и отрицательной.
    Вывод в файл OUTPUT.TXT. В единственной строке вывести минимальную яркость кометы, 
    которую будет наблюдать астрономом в период от 0 до T с точностью 10 знаков после запятой.
Пример
Ввод
2 4
1 1
-1 5
Вывод
3.0000000000


Суть решения:
    Как вы сказали, нужно найти минимум кусочно-линейной функции. Для этого лучше всего использовать тернарный поиск
    (частный случай бинарного поиска).
    Все, что требовалось - изучить алгоритм тернарного поиска (взял статью с e-maxx), а реализовать "просеивание" - дело за малым.
    Да, возможно точность будет отличаться на 0.00000001 из-за слишком частых вычислений, однако я думаю, что это не должно
    сильно повлиять на результат :)

Ставь почаще смайлики :) - они мотивируют решать задачи
    
    Игнатьев Владислав, ПС-22
    Visual Studio Community 2022
*/

#include <iomanip>
#include <fstream>

using namespace std;

const int N = 80000000;
const double eps = 1e-10;

int n, t;
double a[N], b[N];

double tag(double x) {
    double res = -1e18;
    for (int i = 1; i <= n; i++) {
        double cur = a[i] * x + b[i];
        res = max(res, cur);
    }
    return res;
}

double ternary_search(double l, double r) {
    while (r - l > eps) {
        double m1 = l + (r - l) / 3.0;
        double m2 = r - (r - l) / 3.0;
        if (tag(m1) < tag(m2)) {
            r = m2;
        }
        else {
            l = m1;
        }
    }
    return tag(l);
}

int main() {
    ifstream fin("input.txt");
    ofstream fout("output.txt");
    fin >> n >> t;
    for (int i = 1; i <= n; i++) {
        fin >> a[i] >> b[i];
    }
    fout << fixed << setprecision(10) << ternary_search(0, t) << endl;
    return 0;
}