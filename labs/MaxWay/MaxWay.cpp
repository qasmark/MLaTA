/*
12.3. Максимальный путь 1 (6)
    Имеется взвешенный ориентированный ациклический граф. Найти максимальный путь, используя алгоритм Беллмана-Форда.
    Ввод из файла INPUT.TXT. Первая строка входного файла INPUT.TXT содержит 3 числа: 
    N - количество вершин графа (3 ≤ N ≤ 1000),
    M – дуг (3 ≤ M ≤ 500000), A – номер начальной вершины. 
    В следующих M строках по 3 числа, задающих дуги: начало дуги, конец дуги, длина (вес).
    Вывод в файл OUTPUT.TXT. В i-й строке выводится длина максимального пути из вершины A до i-й вершины,
    затем количество вершин максимального пути, а далее номера вершин максимального пути.
    Все числа разделены пробелами. Если пути в некоторую вершину не существует, 
    то в соответствующей строке выводится слово No.
    Если в графе имеется достижимый из начальной вершины цикл положительной длины, то вывод состоит из двух строк.
    В первой строке выводится слово No, а во второй – количество и номера вершин обнаруженного цикла через пробел, начиная с его
    любой вершины и заканчивая ей же. При наличии нескольких циклов вывести информацию о любом из них.

Пример
Ввод 1
4 6 1
1 2 1
1 4 2
2 3 3
2 4 3
3 4 1
4 3 1
Вывод 1
Cycle
3 4 3 4

Ввод 2
5 6 1
1 2 1
1 4 2
2 3 3
2 4 3
3 4 1
5 2 5
Вывод 2
0 1 1
1 2 1 2
4 3 1 2 3
5 4 1 2 3 4
No	

    Игнатьев Владислав, ПС-22
    Visual Studio Community 2022

Описание программы:
    Исходя из условия задания, понятно, что циклы отрицательной длины будут проходиться один раз, тем самым, делая макс. путь.
    (Алгоритм Форда-Беллмана позволяет работать с циклами отрицательной длины)
    Однако надо быть аккуратнее с циклами положительной длины. Они как раз и представляют сложность этой программы.
    
    Перед началом алгоритма создаются два вектора: distance и parent. 
    distance хранит длины кратчайших путей от исходной вершины до всех остальных вершин 
    (изначально установлены в бесконечность INF), а parent хранит информацию о предшествующей вершине на кратчайшем пути.

    В алгоритме два составляющих: 
    1. Этап релаксации ребер.
        Т.е. внешний цикл выполняется N-1 раз, где N - количество вершин.
        На каждой итерации внешнего цикла происходит обновление длин кратчайших путей до всех вершин, 
        используя текущую информацию о кратчайших путях. 
        Внутренний цикл перебирает все ребра графа и обновляет длины кратчайших путей, если найден более короткий путь. 
        Если при этом произошло обновление, то также обновляется информация о предшествующей вершине.
    2. Проверка наличия отрицательных циклов.
        После этапа релаксации ребер выполняется еще один проход по всем ребрам графа. 
        Если при этом произойдет обновление длины кратчайшего пути, это означает наличие отрицательного цикла в графе. 
        В этом случае строится путь от вершины цикла до самой себя и выводится поток.


    Если кратчайший путь до какой-либо вершины не существует (её длина равна INF), выводится "No",
    иначе выводится длиннейший маршрут до вершины. ( что соотвествует условию вывода)

Суть решения:
    Вначале инициализируется граф, затем запускается алгоритм Беллмана-Форда, в котором два этапа: релаксация ребер и
    проверка на циклы положительной длины. Все, что оставалось - "поиграться" с придумыванием тестов, разобраться, 
    как работает релаксация ребер, а затем просто реализовать её. Далее, необходимо было реализовать проверку
    на циклы положительной длины, а потом лишь понять в каком порядке выводить :)

Тесты:
    Тесты я приложу в виде фотографий, а также опишу их тут.
    cin1.txt - простенький тест, проверяющий стандартную логику программы
    cin2.txt - тест, в котором есть ЦПЛ. 
    cin3.txt - тест из Вывод 2
    cin4.txt - тест из Вывод 1
    cin5.txt - тест, в котором есть цикл отрицательной длины
    cin6.txt - просто ветвистый тест
    cin7.txt - тест с ЦПЛ и с циклом отрицательной длины (ЦОД)
    cin8.txt - тест с циклом нулевой длины
*/

#include <iostream>
#include <fstream>
#include <vector>
#include <limits>

const int INF = std::numeric_limits<int>::min();
const std::string inputFile = "input.txt";
const std::string outputFile = "output.txt";


struct Edge 
{
    int source;
    int destination;
    int weight;
};

void bellmanFord(int N, int M, int A, const std::vector<Edge>& edges) 
{
    std::vector<int> distance(N, INF);
    std::vector<int> parent(N, -1);
    distance[A - 1] = 0;
    int v, u, weight;

    // Релаксация ребер 
    for (int i = 1; i < N; ++i) 
    {
        for (int j = 0; j < M; ++j)
        {
            u = edges[j].source - 1;
            v = edges[j].destination - 1;
            weight = edges[j].weight;

            if (distance[u] != INF && distance[u] + weight > distance[v])
            {
                distance[v] = distance[u] + weight;
                parent[v] = u;
            }
        }
    }

    // Проверка на циклы положительной (больше нуля) длины 
    // ЦПЛ - цикл положительной длины
    for (int j = 0; j < M; ++j) 
    {
        u = edges[j].source - 1;
        v = edges[j].destination - 1;
        weight = edges[j].weight;

        if (distance[u] != INF && distance[u] + weight > distance[v]) 
        {
            std::vector<int> cycle;
            int current = v;

            while (current != u && current != -1) 
            {
                cycle.push_back(current + 1);
                current = parent[current];
            }
            cycle.push_back(u + 1);

            // Если находим ЦПЛ выводим его и возвращаемся из функции
            std::ofstream output(outputFile);
            output << "Cycle" << std::endl;
            output << cycle.size() << " ";

            for (int i = cycle.size() - 1; i >= 0; --i) 
            {
                output << cycle[i] << " ";
            }
            output << std::endl;
            output.close(); // так как мы можем не дойти до конца блока выполнения

            return;
        }
    }

    // Если любой ЦПЛ не найден, выводим пути максимальной длины для каждой точки
    std::ofstream output(outputFile);
    for (int i = 0; i < N; ++i) 
    {
        if (distance[i] == INF) 
        {
            output << "No" << std::endl;
        }
        else 
        {
            std::vector<int> path;
            int current = i;

            while (current != -1) 
            {
                path.push_back(current + 1);
                current = parent[current];
            }

            output << distance[i] << " ";
            output << path.size() << " ";

            for (int j = path.size() - 1; j >= 0; --j) 
            {
                output << path[j] << " ";
            }
            output << std::endl;
        }
    }
}

int main() {
    std::ifstream input(inputFile);
    int N, M, A;

    input >> N >> M >> A;
    std::vector<Edge> edges(M);

    for (int i = 0; i < M; ++i) 
    {
        input >> edges[i].source >> edges[i].destination >> edges[i].weight;
    }

    bellmanFord(N, M, A, edges);

    return 0;
}
